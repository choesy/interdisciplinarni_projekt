/* Generated by Edge Impulse
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// Generated on: 01.05.2022 16:02:35

#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#endif

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

constexpr int kTensorArenaSize = 14288;

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};
enum used_operators_e {
  OP_RESHAPE, OP_CONV_2D, OP_MAX_POOL_2D, OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};
struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
  TfLiteQuantization quantization;
};
struct NodeInfo_t { // subset of TfLiteNode used for initialization from constant memory
  struct TfLiteIntArray* inputs;
  struct TfLiteIntArray* outputs;
  void* builtin_data;
  used_operators_e used_op_index;
};

TfLiteContext ctx{};
TfLiteTensor tflTensors[23];
TfLiteEvalTensor tflEvalTensors[23];
TfLiteRegistration registrations[OP_LAST];
TfLiteNode tflNodes[11];

const TfArray<2, int> tensor_dimension0 = { 2, { 1,6435 } };
const TfArray<1, float> quant0_scale = { 1, { 0.0039215688593685627, } };
const TfArray<1, int> quant0_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant0 = { (TfLiteFloatArray*)&quant0_scale, (TfLiteIntArray*)&quant0_zero, 0 };
const ALIGN(16) int32_t tensor_data1[4] = { 1, 1, 99, 65, };
const TfArray<1, int> tensor_dimension1 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data2[4] = { 1, 99, 1, 8, };
const TfArray<1, int> tensor_dimension2 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data3[4] = { 1, 1, 50, 8, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data4[4] = { 1, 50, 1, 16, };
const TfArray<1, int> tensor_dimension4 = { 1, { 4 } };
const ALIGN(8) int32_t tensor_data5[2] = { -1, 400, };
const TfArray<1, int> tensor_dimension5 = { 1, { 2 } };
const ALIGN(16) int8_t tensor_data6[8*1*3*65] = { 
  /* [0][0][][] */ -48,28,-11,85,74,10,61,19,102,66,42,82,42,103,23,-14,13,-1,-12,2,4,37,-5,51,46,26,-79,-24,-16,-28,-23,-9,-65,-25,46,-27,-99,-47,-22,-80,102,30,55,-29,-13,44,20,-58,-5,-14,30,-40,-45,-22,-36,50,-2,-41,19,17,31,66,93,-5,-5, -108,-61,14,61,34,15,70,52,65,73,-6,18,39,-14,-12,16,9,-11,28,66,10,44,-8,-5,-68,-65,-54,-32,-7,-48,-11,-99,-90,-42,9,-18,-60,-33,-90,-20,76,-56,-68,-43,1,-96,-78,-24,-45,-57,-56,-9,-15,-24,-70,-38,-63,26,2,85,78,-1,63,-46,-52, -78,-4,0,-2,-29,43,-14,-47,31,125,34,-29,-27,-47,-18,-3,36,-7,-5,15,-15,-28,-40,23,-69,-78,-82,-55,-85,-52,-59,6,-75,-43,-21,-29,-127,-56,-76,14,40,-22,-40,-92,-64,-8,-16,-76,-57,-98,-50,-39,-17,-46,-47,-65,-78,-21,13,96,57,125,85,7,16, 
  /* [1][0][][] */ -84,-54,-48,-66,12,9,31,44,66,69,36,12,36,13,-25,33,-4,3,-5,-55,-76,15,4,-4,28,43,-2,6,-28,30,-11,-13,-6,-32,-24,-35,-18,-3,9,22,-7,31,10,16,-11,40,45,-15,25,33,15,27,-13,-21,-21,-41,-24,6,-33,-19,17,14,35,32,52, -73,-57,-66,-62,6,-15,51,86,79,23,63,15,24,26,20,-26,-5,0,12,-25,-78,-19,-16,42,23,13,-16,31,1,-28,26,11,-38,-36,-41,-32,-42,-27,20,7,19,36,-17,28,-6,-8,32,45,17,10,30,35,43,32,-7,-17,-25,-17,-19,14,36,-11,-9,30,-19, -127,-67,-55,-64,-9,35,49,103,86,56,-4,9,-3,-30,12,4,9,14,-19,-72,-28,-31,37,21,-4,-1,23,21,-1,-12,-22,32,11,-22,7,-5,5,-20,18,32,21,46,-11,-31,30,-29,21,31,-20,-28,2,-6,-9,-23,1,1,-4,4,-48,-35,-19,16,-20,72,34, 
  /* [2][0][][] */ 81,-64,-57,74,-97,-90,-96,40,-38,-69,-24,58,48,28,-41,-92,26,-1,-22,58,-31,22,-26,34,-12,-22,-13,-68,-64,10,-61,2,40,-74,-25,24,-12,-19,3,1,-68,-42,-41,52,-24,84,8,-11,13,-1,104,11,102,46,54,29,68,32,-4,55,-30,-44,-76,-6,39, 97,-55,54,44,-75,-43,-1,-18,-55,-4,-66,53,15,-59,-25,-99,-115,45,-29,27,-72,43,-9,-67,-105,-30,-51,20,27,-22,-74,-79,-8,-57,-60,37,-52,-49,-23,-94,-34,44,-3,-64,-87,-7,42,66,-1,19,79,49,-43,76,-78,127,-1,74,60,18,68,70,-23,-26,-22, 88,-67,-50,-24,14,24,21,-6,14,-52,22,-10,-15,10,-24,0,-97,-101,-13,39,13,-63,-24,-52,20,-109,24,58,-54,-52,10,-74,61,-81,-6,-51,40,-60,-19,49,31,-94,-63,-2,-71,71,-15,44,69,39,-10,-43,24,87,34,24,99,123,3,62,-30,-35,-47,4,-13, 
  /* [3][0][][] */ -6,40,-11,43,-5,-67,-49,-40,-69,-23,-29,-40,3,31,36,-52,7,-9,-40,13,51,22,15,-47,-2,-44,-25,-43,-52,-2,-18,-34,-18,-26,-38,-26,-46,-18,-61,-81,-81,-75,-59,-103,-36,-19,-36,-52,-60,-44,-103,-48,-94,-99,-63,11,-44,-9,-44,-79,-78,-32,-32,-114,-69, 56,20,16,26,-24,4,-64,-97,-12,-16,-22,-68,-44,46,-14,-8,-20,42,-3,68,48,43,4,8,-14,-8,33,33,9,23,-29,18,25,33,36,-17,-14,-59,-68,-60,-49,-98,-6,-66,-48,-81,-71,-47,12,-18,-7,-79,-52,-14,21,3,-24,-38,-2,39,8,-10,24,0,13, 41,58,12,57,-27,-70,1,-78,-48,-3,-10,-11,15,38,-13,12,-41,-2,-13,-15,-16,-19,-17,-16,-57,-53,14,-21,-6,-42,-48,-24,-38,-3,-9,-47,-16,-15,-101,-106,-127,-80,-71,-103,-88,-56,-121,-49,-39,-89,-74,-68,-81,-31,-84,-43,-66,-84,-44,-17,-118,-99,-60,-100,-100, 
  /* [4][0][][] */ -29,14,-96,19,66,-86,-6,-9,-122,-5,13,58,-13,27,-20,-102,8,-97,-41,-71,0,-35,-4,-102,13,15,-27,-72,80,-104,-25,-95,73,-61,-114,-108,72,82,-85,31,-72,34,-56,-38,30,3,-122,-89,-22,-34,-2,-116,-115,-48,-113,-60,77,-93,-73,61,-29,-106,-79,76,18, 59,-104,18,-2,-13,71,57,-60,-26,73,-16,47,-117,16,-41,-74,-55,71,21,45,-75,-113,-64,12,8,37,-77,49,-10,-55,-98,-99,-31,5,21,23,-47,81,-109,83,-91,-3,32,48,-99,-119,-31,10,-15,10,65,41,29,32,52,37,-36,-4,68,5,26,-53,62,-100,64, -17,-65,54,-101,3,42,58,-2,-23,-12,37,49,-43,12,-41,22,38,-19,8,-67,-97,-101,-50,55,-57,-57,15,-48,83,78,80,-47,-49,70,-57,-3,72,27,-7,15,-43,69,-99,-127,82,-62,-122,-83,-91,-103,-33,8,-12,83,-37,2,-107,78,76,-118,14,-19,59,38,8, 
  /* [5][0][][] */ 17,-22,-6,-10,-25,-47,-57,-61,33,-112,-24,-8,78,-26,-65,6,33,69,-59,50,-21,9,53,-42,-9,-77,86,-73,-53,31,72,35,-107,-29,-48,61,-13,-68,-62,-49,-71,-76,-105,77,-34,56,14,32,-101,69,-67,-117,-72,-81,-43,-34,30,-73,76,-101,-86,-126,-76,-94,-27, -19,20,20,-98,73,29,61,-20,39,32,24,-127,73,8,-5,-18,9,-40,-102,0,-55,48,71,70,-120,-32,74,39,60,-1,83,42,-72,58,-2,-25,-53,0,-67,47,71,52,-16,42,62,-50,-80,-117,-102,80,-116,-75,-22,-30,74,-33,-19,-75,57,-96,-36,-88,88,89,54, -70,-46,-82,74,66,-44,41,-39,-122,-91,6,-2,81,-64,-54,48,-117,-99,11,-107,-44,-26,-11,-55,-46,68,82,44,-89,65,1,-18,-70,71,-50,49,18,-90,-77,-64,0,-123,-43,28,4,-122,68,38,-61,54,-69,-17,-76,2,-111,-69,80,-6,-15,66,9,24,-110,55,-55, 
  /* [6][0][][] */ 9,-10,-26,-11,-39,-13,16,-53,-87,22,-33,5,34,-3,40,18,36,4,15,3,18,3,-19,-5,-50,-76,-58,-45,16,-55,-75,-75,-32,22,-41,-5,-39,-95,-103,-45,-79,-107,-88,-51,-72,-70,-99,-104,-52,-62,-56,-45,-70,-70,-89,-16,-66,-48,-78,1,-58,-45,-48,-70,-121, 65,19,18,82,-17,30,-36,-84,-71,3,23,22,76,32,68,1,76,43,40,69,49,58,12,12,27,-8,9,-5,-5,1,2,-37,-25,4,27,33,-8,-32,-41,-82,-74,-15,-36,7,-55,-38,-53,-18,21,2,9,1,-50,3,11,2,23,-48,-40,12,-7,-48,-24,-58,-70, 82,64,12,49,-32,-39,-35,-43,-76,-52,-41,-18,27,63,50,16,64,49,61,48,59,-42,-67,-10,-35,-26,-26,-9,-66,-71,-40,-70,-45,-43,-23,-16,-16,-52,-85,-29,-87,-112,-39,-96,-44,-111,-51,-44,-63,-70,-64,-22,-26,-82,-100,-61,-54,-9,-64,-63,-56,-36,-82,-127,-112, 
  /* [7][0][][] */ -127,-95,31,93,36,-47,-49,-60,-63,-38,-98,-84,-30,-18,-44,-5,-74,-48,-34,-107,-45,-80,-28,-22,-42,-68,-84,-71,-17,-4,-88,-50,-16,-68,-52,-77,12,-39,14,0,-22,-23,-19,24,-37,-5,26,12,25,-18,-3,-8,-40,-33,14,-62,-8,-1,-7,-59,-26,-45,9,-64,8, -38,16,2,73,54,17,-21,-73,-12,-89,-85,-101,23,-38,-52,-46,-81,-107,-76,-40,-75,-63,-41,-111,-76,-119,-62,-52,-23,-61,-25,-36,-39,-56,-47,-55,-9,-19,-38,-48,-12,32,0,-35,20,-46,-32,-22,-16,6,28,-45,-49,-25,20,-9,-33,6,-9,-61,25,-29,-49,-32,1, -108,-13,104,123,5,37,-22,-92,-61,-38,-49,-58,-31,-34,-54,-38,-57,-97,-35,-68,-86,-60,-85,-88,-114,-72,-80,4,-41,-73,-88,-28,-23,-14,5,-42,-79,-51,-14,7,20,-30,-11,16,-1,-31,25,-28,-32,-42,-8,-1,-34,28,-26,-6,-38,-43,-2,10,-21,-41,-6,-17,-11, 
};
const TfArray<4, int> tensor_dimension6 = { 4, { 8,1,3,65 } };
const TfArray<8, float> quant6_scale = { 8, { 0.0030222190544009209, 0.0047149430029094219, 0.0020584322046488523, 0.0038183168508112431, 0.0015534078702330589, 0.0015358589589595795, 0.0035614606458693743, 0.0038184437435120344, } };
const TfArray<8, int> quant6_zero = { 8, { 0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant6 = { (TfLiteFloatArray*)&quant6_scale, (TfLiteIntArray*)&quant6_zero, 0 };
const ALIGN(16) int32_t tensor_data7[8] = { 3330, -8649, -10300, -4908, -11309, -13259, 3582, -2222, };
const TfArray<1, int> tensor_dimension7 = { 1, { 8 } };
const TfArray<8, float> quant7_scale = { 8, { 1.1851840099552646e-05, 1.8489974536350928e-05, 8.0722838902147487e-06, 1.4973792531236541e-05, 6.0917959672224242e-06, 6.0229767768760212e-06, 1.3966513506602496e-05, 1.497429002483841e-05, } };
const TfArray<8, int> quant7_zero = { 8, { 0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant7 = { (TfLiteFloatArray*)&quant7_scale, (TfLiteIntArray*)&quant7_zero, 0 };
const ALIGN(16) int8_t tensor_data8[16*1*3*8] = { 
  /* [0][0][][] */ -48,-57,-15,87,-29,-38,127,5, 75,-62,-47,-48,-31,-76,64,-57, 51,-60,78,48,24,63,94,-29, 
  /* [1][0][][] */ -127,67,-66,-21,-10,-53,3,34, -114,-109,-19,47,-94,27,-104,-52, 47,62,66,66,59,-44,-108,-51, 
  /* [2][0][][] */ -104,35,-79,-12,2,61,-44,-107, 55,18,-77,59,11,-50,-109,38, 3,-127,-45,-88,3,12,47,-7, 
  /* [3][0][][] */ -33,-45,1,-12,-29,53,-39,98, 24,-105,3,46,36,52,32,34, 33,-127,17,-33,-35,39,47,-30, 
  /* [4][0][][] */ 46,6,22,-36,23,-34,-23,84, -8,-37,9,-16,-29,-40,2,127, 88,-96,64,-11,-32,42,-32,96, 
  /* [5][0][][] */ 16,-63,-106,3,59,82,-68,66, -76,-93,-75,7,44,75,-105,-71, -69,-6,53,-14,52,-11,-127,26, 
  /* [6][0][][] */ -70,15,22,38,12,18,-52,50, -85,14,20,-24,4,54,-19,-124, -127,46,5,16,26,-29,-57,-7, 
  /* [7][0][][] */ -68,-73,63,-31,-51,67,64,11, 33,-91,-127,11,76,42,66,-109, -116,-98,-56,8,39,14,-51,55, 
  /* [8][0][][] */ -37,-48,64,-25,-33,-15,-10,127, 6,-54,-43,55,41,15,37,77, 15,-77,37,-68,-13,-44,75,66, 
  /* [9][0][][] */ -91,-107,11,6,47,43,-127,-90, -1,52,66,-30,25,29,-44,-49, -112,-37,53,0,19,-20,-125,4, 
  /* [10][0][][] */ -53,-31,82,-27,-15,-65,-101,6, 34,56,33,-35,62,15,-1,-105, -15,20,24,-127,-41,-29,28,-78, 
  /* [11][0][][] */ -64,-81,-24,20,-15,-80,0,-80, -127,70,39,-8,-43,0,-103,20, -10,-12,-99,40,107,-81,-46,-2, 
  /* [12][0][][] */ 61,-7,-102,-40,37,68,-17,-115, -31,-71,127,-7,50,-98,-7,19, -3,13,-49,-67,-30,49,10,21, 
  /* [13][0][][] */ 32,0,-43,80,-54,-54,35,2, -95,-50,4,-80,35,-4,-127,-28, -106,-83,-16,11,-10,16,-87,-67, 
  /* [14][0][][] */ -127,15,15,-5,-40,37,-57,-40, -67,30,-44,24,50,1,-29,-10, -123,43,19,-11,2,27,-53,12, 
  /* [15][0][][] */ -6,7,-27,19,-43,-70,-127,-38, -65,-19,-19,-95,74,62,5,-33, -6,-68,27,-71,-27,39,-95,20, 
};
const TfArray<4, int> tensor_dimension8 = { 4, { 16,1,3,8 } };
const TfArray<16, float> quant8_scale = { 16, { 0.0035127908922731876, 0.0024839283432811499, 0.0031210852321237326, 0.004032759927213192, 0.0053971274755895138, 0.0027723831590265036, 0.0054844887927174568, 0.003092300845310092, 0.0045151510275900364, 0.0040172170847654343, 0.0037790385540574789, 0.0026155221275985241, 0.0026207189075648785, 0.0043548517860472202, 0.0055421087890863419, 0.0033979681320488453, } };
const TfArray<16, int> quant8_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant8 = { (TfLiteFloatArray*)&quant8_scale, (TfLiteIntArray*)&quant8_zero, 0 };
const ALIGN(16) int32_t tensor_data9[16] = { 6455, -5566, -4574, -1218, 2213, -5231, -1460, -5219, 5548, -1785, -4606, -4751, -5155, -631, -1596, -4274, };
const TfArray<1, int> tensor_dimension9 = { 1, { 16 } };
const TfArray<16, float> quant9_scale = { 16, { 2.6376612368039787e-05, 1.865115700638853e-05, 2.3435397451976314e-05, 3.028092032764107e-05, 4.0525592339690775e-05, 2.0817087715840898e-05, 4.1181567212333903e-05, 2.3219263312057592e-05, 3.390306665096432e-05, 3.0164213967509568e-05, 2.8375794499879703e-05, 1.9639259335235693e-05, 1.9678280295920558e-05, 3.2699423172743991e-05, 4.1614221117924899e-05, 2.5514438675600104e-05, } };
const TfArray<16, int> quant9_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant9 = { (TfLiteFloatArray*)&quant9_scale, (TfLiteIntArray*)&quant9_zero, 0 };
const ALIGN(16) int8_t tensor_data10[2*400] = { 
  -65, -3, 0, -29, -43, -12, 50, 18, -92, 32, 22, 52, -12, 20, 40, -4, -62, 49, 19, -39, -41, 31, 14, 8, -119, -10, 42, 33, 31, 22, 43, 35, -50, 16, -19, -61, -5, -20, 43, 15, -106, 9, 19, 12, -6, 6, 37, 1, -54, -7, 29, -18, -38, 23, -19, 6, -51, -29, 52, 29, 12, 16, 21, 4, -22, 12, 9, -8, -7, -17, 4, 26, 11, -22, 18, -13, 3, 48, -26, -28, 7, 36, 14, -18, -61, 1, 36, -4, -31, -9, -28, -38, -18, 28, 29, 35, 19, 13, 26, 7, -37, -20, 44, -7, -24, 21, 25, 1, -2, 28, -7, -12, 32, 1, -9, 19, -85, -19, 13, -1, -9, -7, -22, 2, 7, 100, 30, -12, -15, -6, 19, 5, -74, 4, 17, 25, 18, -12, 14, -13, 18, -19, 3, 2, -11, -21, 15, 15, -37, 8, 1, 18, -9, 14, 23, 10, 8, 45, 32, -33, -2, -22, 9, 15, -37, -10, 0, 23, 5, -5, 20, 6, -12, -5, 59, 2, 0, 32, -16, -3, -55, -2, 39, 0, -39, 11, -3, -9, -13, -46, -2, 3, -40, 4, -19, 9, -57, 18, 24, 5, -2, -18, 2, 9, -1, 21, 14, -15, 8, -5, 16, -5, -13, 2, 3, 19, -24, 8, 19, -15, 5, 32, 5, 11, -8, 0, 34, 3, 48, 22, 20, 0, 11, 35, -7, -23, 8, -110, 18, 14, -43, -12, -5, 10, 32, 20, 19, -16, -12, 6, 16, -7, -5, -122, 12, -1, -1, 27, 33, 35, -8, 28, 42, -26, -5, 23, -3, 22, -6, 0, 52, 12, -6, 33, -29, 12, -7, 23, 32, 7, -47, 23, 15, -4, -4, 29, 16, -10, -33, 3, 15, 23, 27, 7, 9, -13, -15, 35, 33, 8, 1, 10, 19, -8, -45, 13, -25, 3, 14, -5, 16, -3, -3, 12, 25, -29, 24, 49, -29, -8, -33, 15, -22, -1, 43, -17, -10, 12, 5, 7, -11, -3, -2, 40, -20, -42, -24, -6, 3, 37, 4, 24, 24, 12, 3, -17, -1, 18, -2, -60, 8, 16, -9, 36, 16, -30, -3, -11, 0, -10, 3, 21, 32, 28, -5, 29, 24, 31, -16, -9, 18, -8, 41, -3, 22, -28, -3, -15, -2, 3, 27, -5, 58, 14, -47, 12, 10, 6, 40, 17, 5, -29, 35, 5, 46, 16, 25, -6, 15, 30, 
  73, -47, -5, 27, 67, 8, -25, -3, 99, -23, -21, -44, 10, -19, -50, -24, 81, -67, 12, 43, 28, -22, -30, -16, 81, -5, 6, -51, -26, -10, -34, -3, 47, -11, 24, 39, 7, -9, -24, -25, 77, 12, -8, 23, -11, -32, -18, 12, 74, 9, -12, 41, 40, -23, 10, 19, 67, -6, -23, -31, -11, -56, -18, 12, 7, 3, -18, -44, 3, -6, 17, -7, -14, -20, -39, 15, -16, -35, 4, 17, -30, -26, 16, -3, 44, -17, -2, -10, 6, -27, 24, 1, 7, -17, -24, -34, -3, 17, 17, -1, 34, 18, -7, 5, 49, -14, -26, 4, -32, -40, 15, 13, -20, -19, 13, -23, 66, -22, -13, 16, 32, 9, 30, 21, -17, -115, -17, 8, 12, 4, -11, 24, 89, -18, -20, -9, 24, 12, 15, 29, -20, 48, -2, -3, 16, -5, 6, 22, 60, -19, -3, -33, 39, -2, 6, -2, 9, -55, -13, -6, 0, 42, 23, 2, 51, 2, -1, 7, -49, -28, 9, -21, -30, 22, -16, -26, 25, -7, 18, 24, 14, -11, -11, 2, -8, 25, 6, 27, 7, 55, -15, -3, 41, -2, -3, -36, 94, -33, -18, -15, 38, 0, 6, 8, 14, -19, -11, 37, 29, -14, 10, -3, 1, -28, 1, -12, -20, 5, -32, -1, 9, -40, -24, -11, 24, -2, -13, 20, -3, 11, -12, -18, -7, -2, 2, 7, -1, 69, 13, 13, 19, 20, 20, 21, -55, -17, -51, 14, 12, 29, -4, -21, 9, 127, -3, -12, 45, -19, 4, -18, -4, 20, -16, 14, -14, -19, -41, -36, 12, -20, -22, -10, 13, -33, -13, -17, -36, -27, -5, -5, 13, -31, 0, -10, -6, -48, -13, 4, 42, -5, -4, -16, -63, -25, -30, 24, -13, -25, 17, 2, 4, -47, -22, 48, 4, 0, 20, -35, -29, -8, 27, -12, -10, -35, -4, 24, 21, -45, -23, 16, 18, 34, 13, -12, -27, 18, -24, 13, -29, -22, 3, -19, 1, -6, -16, 35, 22, -19, -15, -8, -22, -5, -31, 12, -21, -12, 31, 34, 2, 22, -30, -24, 44, 6, 0, 0, -12, 10, -14, 9, -16, -18, -7, -7, -23, -15, -1, -33, 52, -41, -22, -6, -46, -5, -13, 27, 12, -8, -3, 3, -23, -30, -15, 0, 51, -9, 11, -1, -28, 21, -6, 22, 9, -15, -37, 14, 18, 17, -9, 5, 
};
const TfArray<2, int> tensor_dimension10 = { 2, { 2,400 } };
const TfArray<1, float> quant10_scale = { 1, { 0.0045375642366707325, } };
const TfArray<1, int> quant10_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant10 = { (TfLiteFloatArray*)&quant10_scale, (TfLiteIntArray*)&quant10_zero, 0 };
const ALIGN(8) int32_t tensor_data11[2] = { -2796, 2796, };
const TfArray<1, int> tensor_dimension11 = { 1, { 2 } };
const TfArray<1, float> quant11_scale = { 1, { 2.9135679142200388e-05, } };
const TfArray<1, int> quant11_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant11 = { (TfLiteFloatArray*)&quant11_scale, (TfLiteIntArray*)&quant11_zero, 0 };
const TfArray<4, int> tensor_dimension12 = { 4, { 1,1,99,65 } };
const TfArray<1, float> quant12_scale = { 1, { 0.0039215688593685627, } };
const TfArray<1, int> quant12_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant12 = { (TfLiteFloatArray*)&quant12_scale, (TfLiteIntArray*)&quant12_zero, 0 };
const TfArray<4, int> tensor_dimension13 = { 4, { 1,1,99,8 } };
const TfArray<1, float> quant13_scale = { 1, { 0.0075087337754666805, } };
const TfArray<1, int> quant13_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant13 = { (TfLiteFloatArray*)&quant13_scale, (TfLiteIntArray*)&quant13_zero, 0 };
const TfArray<4, int> tensor_dimension14 = { 4, { 1,99,1,8 } };
const TfArray<1, float> quant14_scale = { 1, { 0.0075087337754666805, } };
const TfArray<1, int> quant14_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant14 = { (TfLiteFloatArray*)&quant14_scale, (TfLiteIntArray*)&quant14_zero, 0 };
const TfArray<4, int> tensor_dimension15 = { 4, { 1,50,1,8 } };
const TfArray<1, float> quant15_scale = { 1, { 0.0075087337754666805, } };
const TfArray<1, int> quant15_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant15 = { (TfLiteFloatArray*)&quant15_scale, (TfLiteIntArray*)&quant15_zero, 0 };
const TfArray<4, int> tensor_dimension16 = { 4, { 1,1,50,8 } };
const TfArray<1, float> quant16_scale = { 1, { 0.0075087337754666805, } };
const TfArray<1, int> quant16_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant16 = { (TfLiteFloatArray*)&quant16_scale, (TfLiteIntArray*)&quant16_zero, 0 };
const TfArray<4, int> tensor_dimension17 = { 4, { 1,1,50,16 } };
const TfArray<1, float> quant17_scale = { 1, { 0.0064209955744445324, } };
const TfArray<1, int> quant17_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant17 = { (TfLiteFloatArray*)&quant17_scale, (TfLiteIntArray*)&quant17_zero, 0 };
const TfArray<4, int> tensor_dimension18 = { 4, { 1,50,1,16 } };
const TfArray<1, float> quant18_scale = { 1, { 0.0064209955744445324, } };
const TfArray<1, int> quant18_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant18 = { (TfLiteFloatArray*)&quant18_scale, (TfLiteIntArray*)&quant18_zero, 0 };
const TfArray<4, int> tensor_dimension19 = { 4, { 1,25,1,16 } };
const TfArray<1, float> quant19_scale = { 1, { 0.0064209955744445324, } };
const TfArray<1, int> quant19_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant19 = { (TfLiteFloatArray*)&quant19_scale, (TfLiteIntArray*)&quant19_zero, 0 };
const TfArray<2, int> tensor_dimension20 = { 2, { 1,400 } };
const TfArray<1, float> quant20_scale = { 1, { 0.0064209955744445324, } };
const TfArray<1, int> quant20_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant20 = { (TfLiteFloatArray*)&quant20_scale, (TfLiteIntArray*)&quant20_zero, 0 };
const TfArray<2, int> tensor_dimension21 = { 2, { 1,2 } };
const TfArray<1, float> quant21_scale = { 1, { 0.03895631805062294, } };
const TfArray<1, int> quant21_zero = { 1, { 5 } };
const TfLiteAffineQuantization quant21 = { (TfLiteFloatArray*)&quant21_scale, (TfLiteIntArray*)&quant21_zero, 0 };
const TfArray<2, int> tensor_dimension22 = { 2, { 1,2 } };
const TfArray<1, float> quant22_scale = { 1, { 0.00390625, } };
const TfArray<1, int> quant22_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant22 = { (TfLiteFloatArray*)&quant22_scale, (TfLiteIntArray*)&quant22_zero, 0 };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,1 } };
const TfArray<1, int> outputs0 = { 1, { 12 } };
const TfLiteConvParams opdata1 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs1 = { 3, { 12,6,7 } };
const TfArray<1, int> outputs1 = { 1, { 13 } };
const TfLiteReshapeParams opdata2 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs2 = { 2, { 13,2 } };
const TfArray<1, int> outputs2 = { 1, { 14 } };
const TfLitePoolParams opdata3 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs3 = { 1, { 14 } };
const TfArray<1, int> outputs3 = { 1, { 15 } };
const TfLiteReshapeParams opdata4 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs4 = { 2, { 15,3 } };
const TfArray<1, int> outputs4 = { 1, { 16 } };
const TfLiteConvParams opdata5 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs5 = { 3, { 16,8,9 } };
const TfArray<1, int> outputs5 = { 1, { 17 } };
const TfLiteReshapeParams opdata6 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs6 = { 2, { 17,4 } };
const TfArray<1, int> outputs6 = { 1, { 18 } };
const TfLitePoolParams opdata7 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs7 = { 1, { 18 } };
const TfArray<1, int> outputs7 = { 1, { 19 } };
const TfLiteReshapeParams opdata8 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs8 = { 2, { 19,5 } };
const TfArray<1, int> outputs8 = { 1, { 20 } };
const TfLiteFullyConnectedParams opdata9 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs9 = { 3, { 20,10,11 } };
const TfArray<1, int> outputs9 = { 1, { 21 } };
const TfLiteSoftmaxParams opdata10 = { 1 };
const TfArray<1, int> inputs10 = { 1, { 21 } };
const TfArray<1, int> outputs10 = { 1, { 22 } };
const TensorInfo_t tensorData[] = {
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 6448, (TfLiteIntArray*)&tensor_dimension0, 6435, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant0))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data1, (TfLiteIntArray*)&tensor_dimension1, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data2, (TfLiteIntArray*)&tensor_dimension2, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data3, (TfLiteIntArray*)&tensor_dimension3, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data4, (TfLiteIntArray*)&tensor_dimension4, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data5, (TfLiteIntArray*)&tensor_dimension5, 8, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt8, (void*)tensor_data6, (TfLiteIntArray*)&tensor_dimension6, 1560, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant6))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data7, (TfLiteIntArray*)&tensor_dimension7, 32, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant7))}, },
  { kTfLiteMmapRo, kTfLiteInt8, (void*)tensor_data8, (TfLiteIntArray*)&tensor_dimension8, 384, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant8))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data9, (TfLiteIntArray*)&tensor_dimension9, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant9))}, },
  { kTfLiteMmapRo, kTfLiteInt8, (void*)tensor_data10, (TfLiteIntArray*)&tensor_dimension10, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant10))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data11, (TfLiteIntArray*)&tensor_dimension11, 8, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant11))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension12, 6435, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant12))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 6448, (TfLiteIntArray*)&tensor_dimension13, 792, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant13))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension14, 792, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant14))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 800, (TfLiteIntArray*)&tensor_dimension15, 400, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant15))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension16, 400, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant16))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 800, (TfLiteIntArray*)&tensor_dimension17, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant17))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension18, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant18))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 800, (TfLiteIntArray*)&tensor_dimension19, 400, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant19))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension20, 400, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant20))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 400, (TfLiteIntArray*)&tensor_dimension21, 2, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant21))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension22, 2, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant22))}, },
};const NodeInfo_t nodeData[] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, const_cast<void*>(static_cast<const void*>(&opdata0)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, const_cast<void*>(static_cast<const void*>(&opdata1)), OP_CONV_2D, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, const_cast<void*>(static_cast<const void*>(&opdata2)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, const_cast<void*>(static_cast<const void*>(&opdata3)), OP_MAX_POOL_2D, },
  { (TfLiteIntArray*)&inputs4, (TfLiteIntArray*)&outputs4, const_cast<void*>(static_cast<const void*>(&opdata4)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs5, (TfLiteIntArray*)&outputs5, const_cast<void*>(static_cast<const void*>(&opdata5)), OP_CONV_2D, },
  { (TfLiteIntArray*)&inputs6, (TfLiteIntArray*)&outputs6, const_cast<void*>(static_cast<const void*>(&opdata6)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs7, (TfLiteIntArray*)&outputs7, const_cast<void*>(static_cast<const void*>(&opdata7)), OP_MAX_POOL_2D, },
  { (TfLiteIntArray*)&inputs8, (TfLiteIntArray*)&outputs8, const_cast<void*>(static_cast<const void*>(&opdata8)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs9, (TfLiteIntArray*)&outputs9, const_cast<void*>(static_cast<const void*>(&opdata9)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs10, (TfLiteIntArray*)&outputs10, const_cast<void*>(static_cast<const void*>(&opdata10)), OP_SOFTMAX, },
};
static std::vector<void*> overflow_buffers;
static void * AllocatePersistentBuffer(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  if (current_location - bytes < tensor_boundary) {
    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers.push_back(ptr);
    return ptr;
  }

  current_location -= bytes;

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}
typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;
static std::vector<scratch_buffer_t> scratch_buffers;

static TfLiteStatus RequestScratchBufferInArena(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBuffer(ctx, b.bytes);
  if (!b.ptr) {
    return kTfLiteError;
  }

  scratch_buffers.push_back(b);

  *buffer_idx = scratch_buffers.size() - 1;

  return kTfLiteOk;
}

static void* GetScratchBuffer(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > static_cast<int>(scratch_buffers.size()) - 1) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static TfLiteTensor* GetTensor(const struct TfLiteContext* context,
                               int tensor_idx) {
  return &tflTensors[tensor_idx];
}

static TfLiteEvalTensor* GetEvalTensor(const struct TfLiteContext* context,
                                       int tensor_idx) {
  return &tflEvalTensors[tensor_idx];
}

} // namespace

TfLiteStatus trained_model_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;
  ctx.AllocatePersistentBuffer = &AllocatePersistentBuffer;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArena;
  ctx.GetScratchBuffer = &GetScratchBuffer;
  ctx.GetTensor = &GetTensor;
  ctx.GetEvalTensor = &GetEvalTensor;
  ctx.tensors = tflTensors;
  ctx.tensors_size = 23;
  for(size_t i = 0; i < 23; ++i) {
    tflTensors[i].type = tensorData[i].type;
    tflEvalTensors[i].type = tensorData[i].type;
    tflTensors[i].is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    tflTensors[i].allocation_type = tensorData[i].allocation_type;
#else
    tflTensors[i].allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
    tflTensors[i].bytes = tensorData[i].bytes;
    tflTensors[i].dims = tensorData[i].dims;
    tflEvalTensors[i].dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    if(tflTensors[i].allocation_type == kTfLiteArenaRw){
      uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

     tflTensors[i].data.data =  start;
     tflEvalTensors[i].data.data =  start;
    }
    else{
       tflTensors[i].data.data = tensorData[i].data;
       tflEvalTensors[i].data.data = tensorData[i].data;
    }
#else
    tflTensors[i].data.data = tensorData[i].data;
    tflEvalTensors[i].data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
    tflTensors[i].quantization = tensorData[i].quantization;
    if (tflTensors[i].quantization.type == kTfLiteAffineQuantization) {
      TfLiteAffineQuantization const* quant = ((TfLiteAffineQuantization const*)(tensorData[i].quantization.params));
      tflTensors[i].params.scale = quant->scale->data[0];
      tflTensors[i].params.zero_point = quant->zero_point->data[0];
    }
    if (tflTensors[i].allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tflTensors[i].data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }
  if (tensor_boundary > current_location /* end of arena size */) {
    printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }
  registrations[OP_RESHAPE] = Register_RESHAPE();
  registrations[OP_CONV_2D] = Register_CONV_2D();
  registrations[OP_MAX_POOL_2D] = Register_MAX_POOL_2D();
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for(size_t i = 0; i < 11; ++i) {
    tflNodes[i].inputs = nodeData[i].inputs;
    tflNodes[i].outputs = nodeData[i].outputs;
    tflNodes[i].builtin_data = nodeData[i].builtin_data;
tflNodes[i].custom_initial_data = nullptr;
      tflNodes[i].custom_initial_data_size = 0;
if (registrations[nodeData[i].used_op_index].init) {
      tflNodes[i].user_data = registrations[nodeData[i].used_op_index].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
    }
  }
  for(size_t i = 0; i < 11; ++i) {
    if (registrations[nodeData[i].used_op_index].prepare) {
      TfLiteStatus status = registrations[nodeData[i].used_op_index].prepare(&ctx, &tflNodes[i]);
      if (status != kTfLiteOk) {
        return status;
      }
    }
  }
  return kTfLiteOk;
}

static const int inTensorIndices[] = {
  0, 
};
TfLiteTensor* trained_model_input(int index) {
  return &ctx.tensors[inTensorIndices[index]];
}

static const int outTensorIndices[] = {
  22, 
};
TfLiteTensor* trained_model_output(int index) {
  return &ctx.tensors[outTensorIndices[index]];
}

TfLiteStatus trained_model_invoke() {
  for(size_t i = 0; i < 11; ++i) {
    TfLiteStatus status = registrations[nodeData[i].used_op_index].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus trained_model_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif
  scratch_buffers.clear();
  for (size_t ix = 0; ix < overflow_buffers.size(); ix++) {
    free(overflow_buffers[ix]);
  }
  overflow_buffers.clear();
  return kTfLiteOk;
}
